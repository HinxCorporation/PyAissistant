from typing import List, Optional

from openai.types.chat.chat_completion_message import ChatCompletionMessage
from openai.types.chat.chat_completion_message_tool_call import ChatCompletionMessageToolCall, Function

from .Chat import *
from .chat_bot_util import *


class ChatBot:
    def __init__(self, write_out):
        self.current_chat: Chat
        self.current_chat = None
        self.chats = []
        self.tools = []
        self.new_chat()
        self._write_out = write_out

    def new_chat(self):
        self.current_chat = Chat()
        self.current_chat.id = generate_uuid(32)
        self.chats.append(self.current_chat)

    def post_prompt(self, prompt: str):
        """Set the system prompt for the chat bot."""
        self.current_chat.system_prompt = prompt

    def chat(self, message: str):
        """Handle incoming messages and manage the conversation."""
        usr_mgs = Message(message)
        usr_mgs.id = generate_uuid(28)
        self.current_chat.messages.append(usr_mgs)
        response, dialog_id, extras = self._generate_response(message)
        return self.bot_continue(response, dialog_id, extras)

    def bot_continue(self, _response, _dialog_id, _extras):
        if _response is not None:
            bot_msg = Message(_response, BOT_ROLE, sid=_dialog_id)
            self.current_chat.messages.append(bot_msg)
        if _extras is not None and 'function_calls' in _extras:
            extra_calls = _extras['function_calls']
            if extra_calls is not None and len(extra_calls) > 0:
                self.current_chat.messages.append(self.calls_to_chain(extra_calls))
                if self.process_extra_items(_extras):
                    response, dialog_id, extras = self._self_continue()
                    return _response + self.bot_continue(response, dialog_id, extras)
        return _response

    def calls_to_chain(self, call_stack):
        if call_stack is None or len(call_stack) > 0:
            return ToolCallMessage(call_stack)
        calls: Optional[List[ChatCompletionMessageToolCall]] = []
        for call in call_stack:
            completed_call = self.complete_call(call)
            if completed_call is not None:
                calls.append(completed_call)
            else:
                print(f"Skipping call due to parsing error: {call}")

        if len(calls) > 0:
            return ChatCompletionMessage(tool_calls=calls)
        else:
            print(f"None Calls to chain")
            return None

    def _generate_response(self, message: str):
        """Generate a response based on the incoming message."""
        # Placeholder for actual response generation logic
        # returns more items with extra if you wants to
        return f"Echo: {message}", 'id', None

    def _self_continue(self):
        # calls while tools response
        # function will like generate_response , but did not send anything.
        return "call nothing", '', None

    def message_chain(self):
        return [*self.get_system_prompt(), *[parse_message(m) for m in self.messages]]

    def get_system_prompt(self) -> []:
        return [get_message(self.system_prompt, SYS_ROLE)]

    @property
    def messages(self):
        """List of messages in the conversation."""
        return self.current_chat.messages

    @property
    def system_prompt(self):
        """The system prompt for the chat bot."""
        return self.current_chat.system_prompt

    @property
    def context(self):
        """The context of the conversation."""
        return self.current_chat.context

    @context.setter
    def context(self, value: dict):
        self.current_chat.context = value

    def process_extra_items(self, extra_items):
        """Process extra items generated by the chat bot."""
        is_continue = False
        if 'function_calls' in extra_items:
            tools = extra_items['function_calls']
            if tools is not None:
                if self.call_tools(tools):
                    is_continue = True
        return is_continue

    def get_function_by_name(self, name):
        for tool in self.tools:
            if 'function' in tool and tool['function']['name'] == name:
                return tool
        return None

    def execute_func(self, function_tool, **kwargs):
        self._write_out(f'----------call-tool-----------\n')
        return function_tool.invoke(**kwargs)

    def add_call_result(self, tool_name, result, tool_call_id):
        tool_response = ToolResponse(result, tool_call_id)
        # usr_mgs.id = generate_uuid(28)
        self.current_chat.messages.append(tool_response)

    def call_tools(self, stacks):
        # messages.append({"role": "tool", "tool_call_id": tool.id, "content": "24â„ƒ"})
        # self._write_out('----------extra-item-----------\n')
        already_called_tools = False
        if stacks is not None and len(stacks) > 0:
            index = 0
            already_called_tools = True
            for item in stacks:
                tool_name = item.get_function_name()
                _tool = self.get_function_by_name(tool_name)
                tool_call_id = item.get_function_call_id()
                # exec_result = ""
                if _tool is not None:
                    try:
                        exec_result = self.execute_func(_tool, **item.args_dict())
                    except Exception as e:
                        exec_result = f"failed execute :{item.call_expression()} , error: {e}"
                else:
                    index += 1
                    exec_result = f"missing execute :{item.call_expression()}"
                self.add_call_result(tool_name, exec_result, tool_call_id)
            if index > 0:
                self._write_out(f'\n----------missing functions {index}-----------\n')
        return already_called_tools

    @staticmethod
    def complete_call(call):
        call_id: str = call.get_function_call_id()
        call_name: str = call.get_function_name()
        args_dict: str = call.call_func_arg
        # print(f"call_id: {call_id}, call_name: {call_name}, args_dict: {args_dict}")
        func = Function(arguments=args_dict, name=call_name)
        return ChatCompletionMessageToolCall(
            id=call_id,
            function=func
        )
