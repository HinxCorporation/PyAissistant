import configparser
import logging

from openai.types.chat.chat_completion_message_tool_call import ChatCompletionMessageToolCall, Function

from .Chat import *
from .ai_executor import AIExecutor
from .chat_bot_util import *
from ..Extension.ai_extension import *


class ChatBot:
    def __init__(self, write_out):
        self.current_chat: Chat
        self.current_chat = None
        self.chats = []
        # self.tools = []
        self.new_chat()
        self._write_out = write_out

    def new_chat(self):
        self.current_chat = Chat()
        self.current_chat.id = generate_uuid(32)
        self.chats.append(self.current_chat)

    def post_prompt(self, prompt: str):
        """Set the system prompt for the chat bot."""
        self.current_chat.system_prompt = prompt

    def chat(self, message: str):
        """Handle incoming messages and manage the conversation."""
        usr_mgs = Message(message)
        usr_mgs.id = generate_uuid(28)
        self.current_chat.messages.append(usr_mgs)
        response, dialog_id, extras = self._generate_response(message)
        return self.bot_continue(response, dialog_id, extras)

    def bot_continue(self, _response, _dialog_id, _extras):
        if _response is not None:
            bot_msg = Message(_response, BOT_ROLE, sid=_dialog_id)
            self.current_chat.messages.append(bot_msg)
        if _extras is not None and 'function_calls' in _extras:
            extra_calls = _extras['function_calls']
            if extra_calls is not None and len(extra_calls) > 0:
                self.current_chat.messages.append(self.calls_to_chain(extra_calls))
                # execute function
                if self.process_extra_items(_extras):
                    response, dialog_id, extras = self._self_continue()
                    return _response + self.bot_continue(response, dialog_id, extras)
        return _response

    @staticmethod
    def calls_to_chain(call_stack):
        if call_stack is not None and len(call_stack) > 0:
            return ToolCallMessage(call_stack)
        return None

    def _generate_response(self, message: str):
        """Generate a response based on the incoming message."""
        # Placeholder for actual response generation logic
        # returns more items with extra if you wants to
        return f"Echo: {message}", 'id', None

    def _self_continue(self):
        # calls while tools response
        # function will like generate_response , but did not send anything.
        return "call nothing", '', None

    def message_chain(self):
        return [*self.get_system_prompt(), *[parse_message(m) for m in self.messages]]

    def get_system_prompt(self) -> []:
        return [get_message(self.system_prompt, SYS_ROLE)]

    @property
    def tools(self):
        """List of tools available for the chat bot."""
        return []

    @property
    def messages(self):
        """List of messages in the conversation."""
        return self.current_chat.messages

    @property
    def system_prompt(self):
        """The system prompt for the chat bot."""
        return self.current_chat.system_prompt

    @property
    def context(self):
        """The context of the conversation."""
        return self.current_chat.context

    @context.setter
    def context(self, value: dict):
        self.current_chat.context = value

    def process_extra_items(self, extra_items):
        """Process extra items generated by the chat bot."""
        is_continue = False
        if 'function_calls' in extra_items:
            tools = extra_items['function_calls']
            if tools is not None:
                if self.call_tools(tools):
                    is_continue = True
        else:
            pass
        return is_continue

    def get_function_by_name(self, name):
        for tool in self.tools:
            if 'function' in tool and tool['function']['name'] == name:
                return tool
        return None

    def execute_func(self, function_tool, **kwargs):
        self._write_out(f'----------call-tool-----------\n')
        return function_tool.invoke(**kwargs)

    def add_call_result(self, tool_name, result, tool_call_id):
        tool_response = ToolResponse(result, tool_call_id)
        # usr_mgs.id = generate_uuid(28)
        self.current_chat.messages.append(tool_response)

    def call_tools(self, stacks):
        # messages.append({"role": "tool", "tool_call_id": tool.id, "content": "24â„ƒ"})
        # self._write_out('----------extra-item-----------\n')
        already_called_tools = False
        if stacks is not None and len(stacks) > 0:
            index = 0
            already_called_tools = True
            for item in stacks:
                tool_name = item.get_function_name()
                _tool = self.get_function_by_name(tool_name)
                tool_call_id = item.get_function_call_id()
                if _tool is not None:
                    try:
                        exec_result = self.execute_func(_tool, **item.args_dict())
                    except Exception as e:
                        exec_result = f"failed execute :{item.call_expression()} , error: {e}"
                else:
                    index += 1
                    exec_result = f"missing execute :{item.call_expression()}"
                self.add_call_result(tool_name, exec_result, tool_call_id)
            if index > 0:
                self._write_out(f'\n----------missing functions {index}-----------\n')
        return already_called_tools

    @staticmethod
    def complete_call(call):
        call_id: str = call.get_function_call_id()
        call_name: str = call.get_function_name()
        args_dict: str = call.call_func_arg
        # print(f"call_id: {call_id}, call_name: {call_name}, args_dict: {args_dict}")
        func = Function(arguments=args_dict, name=call_name)
        return ChatCompletionMessageToolCall(
            id=call_id,
            function=func
        )


class HinxtonChatBot(ChatBot):
    def __init__(self, write_out, function_call_feat=False):
        super().__init__(write_out)
        config_file = 'config.ini'
        config = configparser.ConfigParser()
        try:
            config.read(config_file, encoding='utf-8')
            current = config.get('ai', 'current')
            self.key = config.get(current, "key")
            self.url = config.get(current, "url")
            self.host = config.get(current, "host")
            self.model = config.get(current, "current")
            color_block_options = config.options('Colors')
            self.colors = dict()
            for key in color_block_options:
                self.colors[key] = config.get('Colors', key)

        except (configparser.NoSectionError, configparser.NoOptionError) as e:
            logging.error(f"Error reading config file: {e}")
        self.stream = True  # open async stream
        self.max_tokens = 2048
        self.temperature = 1
        self.top_p = 1
        self.function_call_features = function_call_feat
        if function_call_feat:
            self.executor = AIExecutor()
            self.setup_function_tools()
        else:
            self.executor = None

    def setup_function_tools(self):
        functions = list_exposed_functions()
        self.executor.extend_tools(functions)

    def get_color(self, colorName):
        exist = self.colors.__contains__(colorName)
        if exist:
            color = self.colors[colorName]
        else:
            color = None
        return exist, color

    @property
    def tools(self):
        return self.executor.tools

    def execute_func(self, function_tool, **kwargs):
        if not self.function_call_features:
            return ''
        return self.executor.execute(function_tool, **kwargs)

    def _generate_response(self, user_input: str) -> [str, str, dict]:
        return self._self_continue()
